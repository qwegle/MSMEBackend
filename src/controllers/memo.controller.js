const Memorandum = require('../models/memorandum'); // adjust path as needed
const OTSForm = require('../models/otsform'); // make sure this path is correct

const uploadPdf = async (req, res) => {
  try {
    const filePath = req.file ? `/uploads/${req.file.filename}` : null;

    if (!filePath) {
      return res.status(400).json({ error: 'PDF file is required' });
    }

    const { userId, otsFormId, ackId } = req.body;

    const newPdf = new Memorandum({
      userId,
      otsFormId,
      ackId,
      pdf_link: filePath, // assumes schema has pdf_link to store path
    });

    await newPdf.save();

    if (otsFormId) {
      await OTSForm.findByIdAndUpdate(
        otsFormId,
        { status_msg: "Memorandum generated by branch office" },
        { new: true }
      );
    } else {
      console.warn('No otsFormId provided in request body.');
    }

    res.status(201).json({
      message: 'PDF uploaded successfully',
      id: newPdf._id,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};


// admin office accept or reject the application.
const updateMemoStatus = async (req, res) => {
  try {
    const { memoId, status, remarks } = req.body;

    const updatedMemo = await Memorandum.findByIdAndUpdate(
      memoId,
      { status, remarks },
      { new: true }
    );

    if (!updatedMemo) {
      return res.status(404).json({ message: 'Memorandum not found' });
    }

    // If rejected, update OTSForm status_msg
    if (status === 0) {
      await OTSForm.findByIdAndUpdate(
        updatedMemo.otsFormId,
        { status_msg: "application is rejected by head office" }
      );
    } else if (status === 1) {
      await OTSForm.findByIdAndUpdate(
        updatedMemo.otsFormId,
        { status_msg: "Application is being processed by admin office" }
      );
    }

    res.json({ message: 'Memo status updated successfully', memo: updatedMemo });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// reupload from branch office
const reuploadMemo = async (req, res) => {
  try {
    const { userId, otsFormId, ackId } = req.body;

    if (!req.file) {
      return res.status(400).json({ error: 'No PDF file uploaded' });
    }
    const lastMemo = await Memorandum.findOne({ otsFormId }).sort({ memoVersion: -1 });
    const newMemo = new Memorandum({
      userId,
      otsFormId,
      ackId,
      status: 1, // Default to approved; update later by HO
      remarks: "Resubmitted after rejection",
      memoVersion: lastMemo ? lastMemo.memoVersion + 1 : 1,
      pdfData: {
        data: req.file.buffer,
        contentType: req.file.mimetype,
      },
    });

    await newMemo.save();

    // Update status_msg in OTSForm
    await OTSForm.findByIdAndUpdate(
      otsFormId,
      { status_msg: "memorandum regenerated by branch office" }
    );

    res.status(201).json({ message: 'Memorandum reuploaded successfully', memoId: newMemo._id });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

const getMemosByUserId = async (req, res) => {
  try {
    const { userId } = req.params;

    if (!userId) {
      return res.status(400).json({ error: 'User ID is required' });
    }

    const memos = await Memorandum.find({ userId }).sort({ createdAt: -1 });

    if (!memos.length) {
      return res.status(404).json({ message: 'No memorandums found for this user' });
    }

    res.json(memos);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

const getAllMemos = async (req, res) => {
  try {
    const memos = await Memorandum.find().sort({ createdAt: -1 }); // newest first
    res.json(memos);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};


// // Get PDF by ID (view or download)
// const getPdfById = async (req, res) => {
//   try {
//     const { id } = req.params;
//     const pdfDoc = await Memorandum.findById(id);

//     if (!pdfDoc || !pdfDoc.pdfData?.data) {
//       return res.status(404).json({ error: 'PDF not found' });
//     }

//     res.set({
//       'Content-Type': pdfDoc.pdfData.contentType || 'application/pdf',
//       'Content-Disposition': 'inline; filename="document.pdf"', // use "attachment" for download
//     });

//     res.send(pdfDoc.pdfData.data);
//   } catch (err) {
//     res.status(500).json({ error: err.message });
//   }
// };

// // Optional: List all PDFs
// const listAllPdfs = async (req, res) => {
//   try {
//     const pdfs = await Memorandum.find().select('-pdfData'); // exclude binary data for listing
//     res.json(pdfs);
//   } catch (err) {
//     res.status(500).json({ error: err.message });
//   }
// };

module.exports = {
  uploadPdf,
  updateMemoStatus,
  reuploadMemo,
  getMemosByUserId,
  getAllMemos
//   getPdfById,
//   listAllPdfs,
};
