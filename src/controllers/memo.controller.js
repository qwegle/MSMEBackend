const Memorandum = require('../models/memorandum');
const OTSForm = require('../models/otsform');
const AckForm = require('../models/acknowledgement');
const User = require('../models/user');

const uploadPdf = async (req, res) => {
  try {
    const filePath = req.file ? `${process.env.NODE_APP_URL}/uploads/${req.file.filename}` : null;
    if (!filePath) {
      return res.status(400).json({ error: 'PDF file is required' });
    }
    const { loan_number } = req.body;
    if (!loan_number) {
      return res.status(400).json({ error: 'loan_number is required' });
    }
    const otsForm = await OTSForm.findOne({ loan_number });
    if (!otsForm) {
      return res.status(404).json({ error: 'OTSForm not found for given loan_number' });
    }
    const userId = otsForm.userId;
    const otsFormId = otsForm._id;
    const ackForm = await AckForm.findOne({ ots_form_id: otsFormId });
    if (!ackForm) {
      return res.status(404).json({ error: 'Acknowledgement form not found for this OTSForm' });
    }
    const existingMemo = await Memorandum.findOne({ otsFormId });
    if (existingMemo) {
      return res.status(400).json({ 
        error: 'Memorandum already exists for this loan number' 
      });
    }
    const ackId = ackForm._id;
    const newMemo = new Memorandum({
      userId,
      otsFormId,
      ackId,
      pdfData: filePath,
    });
    await newMemo.save();
    await OTSForm.findByIdAndUpdate(
      otsFormId,
      { status_msg: 'Memorandum generated by branch office' },
      { new: true }
    );
    res.status(201).json({
      message: 'PDF uploaded and memorandum saved successfully',
      id: newMemo._id,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};
// super admin api
const updateMemoStatus = async (req, res) => {
  try {
    const { memoId, status, remarks } = req.body;

    if (!memoId || status === undefined) {
      return res.status(400).json({ message: 'memoId and status are required' });
    }
    const validStatuses = [0, 1, 2];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({ message: 'Invalid status value' });
    }
    const updatedMemo = await Memorandum.findByIdAndUpdate(
      memoId,
      { status, remarks },
      { new: true }
    );
    if (!updatedMemo) {
      return res.status(404).json({ message: 'Memorandum not found' });
    }
    const otsStatusMsgMap = {
      0: "Application is being processed by admin office",
      1: "Application has been approved..",
      2: "Application is rejected by head office"
    };
    await OTSForm.findByIdAndUpdate(
      updatedMemo.otsFormId,
      { status_msg: otsStatusMsgMap[status] }
    );

    res.json({ message: 'Memo status updated successfully', memo: updatedMemo });
  } catch (err) {
    console.error("Error updating memo status:", err);
    res.status(500).json({ error: 'Internal server error' });
  }
};

const reuploadMemo = async (req, res) => {
  try {
    const filePath = req.file ? `${process.env.NODE_APP_URL}/uploads/${req.file.filename}` : null;
    if (!filePath) {
      return res.status(400).json({ error: 'PDF file is required' });
    }

    const { loan_number } = req.body;
    if (!loan_number) {
      return res.status(400).json({ error: 'loan_number is required' });
    }

    const otsForm = await OTSForm.findOne({ loan_number });
    if (!otsForm) {
      return res.status(404).json({ error: 'OTSForm not found for given loan_number' });
    }

    const otsFormId = otsForm._id;
    const ackForm = await AckForm.findOne({ ots_form_id: otsFormId });
    if (!ackForm) {
      return res.status(404).json({ error: 'Acknowledgement form not found for this OTSForm' });
    }
    const existingMemo = await Memorandum.findOne({ otsFormId });
    if (existingMemo) {
      existingMemo.pdfData = filePath;
      await existingMemo.save();

      await OTSForm.findByIdAndUpdate(
        otsFormId,
        { status_msg: 'Memorandum reuploaded by branch office' },
        { new: true }
      );

      return res.status(200).json({
        message: 'PDF reuploaded and memorandum updated successfully',
        id: existingMemo._id,
      });
    } else {
      const newMemo = new Memorandum({
        userId: otsForm.userId,
        otsFormId,
        ackId: ackForm._id,
        pdfData: filePath,
      });

      await newMemo.save();

      await OTSForm.findByIdAndUpdate(
        otsFormId,
        { status_msg: 'Memorandum uploaded (first-time) by branch office' },
        { new: true }
      );

      return res.status(201).json({
        message: 'PDF uploaded and new memorandum created',
        id: newMemo._id,
      });
    }

  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};


const getMemosByUserId = async (req, res) => {
  try {
    const { userId } = req.params;

    if (!userId) {
      return res.status(400).json({ error: 'User ID is required' });
    }

    const memos = await Memorandum.find({ userId }).sort({ createdAt: -1 });

    if (!memos.length) {
      return res.status(404).json({ message: 'No memorandums found for this user' });
    }

    res.json(memos);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// const getAllMemos = async (req, res) => {
//   try {
//     const memos = await Memorandum.find().sort({ createdAt: -1 });
//     res.json(memos);
//   } catch (err) {
//     res.status(500).json({ error: err.message });
//   }
// };
const getAllMemos = async (req, res) => {
  try {
    const { loan_number, userId, branch, status } = req.body;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;

    let memoFilter = {};
    let otsFilter = {};

    if (loan_number) {
      const otsForm = await OTSForm.findOne({ loan_number });
      if (!otsForm) {
        return res.status(404).json({ error: 'No OTS Form found for the given loan number' });
      }
      memoFilter.otsFormId = otsForm._id;
    } else {
      let userFilter = {};
      if (userId) userFilter._id = userId;
      if (branch) otsFilter.branch = branch;
      if (status) memoFilter.status = status;

      let matchedUserIds = [];
      if (Object.keys(userFilter).length > 0) {
        const users = await User.find(userFilter).select('_id');
        matchedUserIds = users.map(user => user._id);
      }

      if (matchedUserIds.length > 0) {
        otsFilter.userId = { $in: matchedUserIds };
      }

      const matchedOtsForms = await OTSForm.find(otsFilter).select('_id');
      const matchedOtsIds = matchedOtsForms.map(ots => ots._id);

      if (matchedOtsIds.length > 0) {
        memoFilter.otsFormId = { $in: matchedOtsIds };
      } else {
        return res.json({
          paginatedData: [],
          page,
          limit,
          totalItems: 0,
          totalPages: 0,
          previousPage: null,
          nextPage: null,
          currentPageCount: 0
        });
      }
    }

    const totalItems = await Memorandum.countDocuments(memoFilter);
    const totalPages = Math.ceil(totalItems / limit);
    const startIndex = (page - 1) * limit;

    const memos = await Memorandum.find(memoFilter)
      .sort({ createdAt: -1 })
      .skip(startIndex)
      .limit(limit)
      .populate('userId', 'username email user_type user_role branch aadharNumber')
      .populate('otsFormId')
      .populate('ackId');

    res.json({
      paginatedData: memos,
      page,
      limit,
      totalItems,
      totalPages,
      previousPage: page > 1 ? page - 1 : null,
      nextPage: page < totalPages ? page + 1 : null,
      currentPageCount: memos.length
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};




// // Get PDF by ID (view or download)
// const getPdfById = async (req, res) => {
//   try {
//     const { id } = req.params;
//     const pdfDoc = await Memorandum.findById(id);

//     if (!pdfDoc || !pdfDoc.pdfData?.data) {
//       return res.status(404).json({ error: 'PDF not found' });
//     }

//     res.set({
//       'Content-Type': pdfDoc.pdfData.contentType || 'application/pdf',
//       'Content-Disposition': 'inline; filename="document.pdf"', // use "attachment" for download
//     });

//     res.send(pdfDoc.pdfData.data);
//   } catch (err) {
//     res.status(500).json({ error: err.message });
//   }
// };

// // Optional: List all PDFs
// const listAllPdfs = async (req, res) => {
//   try {
//     const pdfs = await Memorandum.find().select('-pdfData'); // exclude binary data for listing
//     res.json(pdfs);
//   } catch (err) {
//     res.status(500).json({ error: err.message });
//   }
// };

module.exports = {
  uploadPdf,
  updateMemoStatus,
  reuploadMemo,
  getMemosByUserId,
  getAllMemos
//   getPdfById,
//   listAllPdfs,
};
