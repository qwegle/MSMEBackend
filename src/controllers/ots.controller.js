const mongoose = require('mongoose');
const OTSForm = require('../models/otsform');
const validator = require('validator');
const AckForm = require('../models/acknowledgement');
const Memorandum = require('../models/memorandum');
const CertificateOrder = require('../models/certificate');
const { sendApplicationSubmittedEmail } = require('../utils/sendStatusChangeEmail');
const catchAsync = require('../utils/catchAsync');
const AppError = require('../utils/AppError');

const sanitizeInput = input =>
  typeof input === 'string' ? validator.escape(input.trim()) : input;

exports.createOTSForm = catchAsync(async (req, res, next) => {
  const formData = { ...req.body, userId: req.user.id };
  const baseTimestamp = Date.now();
  let attempt = 0;

  while (attempt < 10) {
    formData.loan_number = `${baseTimestamp}`.slice(0, 12) + attempt;
    try {
      const newForm = new OTSForm(formData);
      await newForm.save();
      await sendApplicationSubmittedEmail(newForm);
      return res.status(201).json({ message: 'OTS Form submitted successfully', data: newForm });
    } catch (err) {
      if (err.code === 11000 && err.message.includes('loan_number')) {
        attempt++;
      } else {
        return next(new AppError(err.message, 500));
      }
    }
  }
  return next(new AppError('Server busy. Please try again.', 500));
});


exports.getUserOTSForms = catchAsync(async (req, res) => {
  const forms = await OTSForm.find({ userId: req.user.id }).sort({ createdAt: -1 });
  res.status(200).json(forms);
});


exports.getOTSFormById = catchAsync(async (req, res, next) => {
  const form = await OTSForm.findOne({ _id: req.params.id, userId: req.user.id });
  if (!form) return next(new AppError('OTS form not found', 404));
  res.status(200).json(form);
});


exports.getAllOTSForms = catchAsync(async (req, res) => {
  const forms = await OTSForm.find().populate('userId', 'first_name last_name email');
  res.status(200).json(forms);
});


exports.getOTSFormsByBranch = catchAsync(async (req, res, next) => {
  const { branch } = req.query;
  if (!branch) return next(new AppError('Branch is required as query parameter', 400));
  const forms = await OTSForm.find({ branch }).sort({ createdAt: -1 });
  res.status(200).json(forms);
});


exports.updateOTSForm = catchAsync(async (req, res, next) => {
  const updatedForm = await OTSForm.findOneAndUpdate(
    { _id: req.params.id, userId: req.user.id },
    req.body,
    { new: true, runValidators: true }
  );
  if (!updatedForm) return next(new AppError('OTS form not found or unauthorized', 404));
  res.status(200).json({ message: 'OTS form updated successfully', data: updatedForm });
});


exports.trackStatus = catchAsync(async (req, res, next) => {
  const { loan_number } = req.body;

  if (!loan_number) {
    return next(new AppError('Loan number is required', 400));
  }

  const application = await OTSForm.findOne({ loan_number });

  if (!application) {
    return next(new AppError('Application not found', 404));
  }

  const statusFlow = [
    "Application submitted",
    "Acknowledgement generated by branch office",
    "Memorandum generated by branch office",
    "Settlement Order generated by admin office",
    "Certificate order uploaded and status updated successfully"
  ];

  const currentStatus = application.status_msg;
  const progressIndex = statusFlow.indexOf(currentStatus);

  if (progressIndex === -1) {
    return next(new AppError('Invalid status in application record', 500));
  }

  res.status(200).json({
    success: true,
    loan_number,
    currentStatus,
    progressIndex,
    statusList: statusFlow.slice(0, progressIndex + 1),
    // allStatuses: statusFlow
  });
});



exports.ApproveRejectOtsApplication = catchAsync(async (req, res, next) => {
  const { otsFormId, flag } = req.body;
  if (![1, 2].includes(flag)) {
    return next(new AppError('Flag value must be 1 (Approved) or 2 (Rejected)', 400));
  }

  const status_msg = flag === 1 ? 'OTS Application approved' : 'OTS Application rejected';

  const updatedForm = await OTSForm.findByIdAndUpdate(
    otsFormId,
    { status: flag, status_msg },
    { new: true }
  );

  if (!updatedForm) return next(new AppError('OTS application not found', 404));
  res.status(200).json({ message: status_msg, form: updatedForm });
});


exports.approveOtsApplication = catchAsync(async (req, res, next) => {
  const { otsFormId } = req.body;
  const updatedForm = await OTSForm.findByIdAndUpdate(
    otsFormId,
    { status: 1, status_msg: 'OTS Application approved' },
    { new: true }
  );
  if (!updatedForm) return next(new AppError('OTS application not found', 404));
  res.status(200).json({ message: 'OTS application approved successfully', form: updatedForm });
});


exports.filterOTS = catchAsync(async (req, res, next) => {
  const { user_role, id: requesterId } = req.user;
  const { otsId, userId, branch, status } = req.body;
  const page = parseInt(req.body.page) || 1;
  const limit = parseInt(req.body.limit) || 10;
  const skip = (page - 1) * limit;

  const clean = (val) => (typeof val === 'string' && val.trim() === '') ? undefined : val;
  const cleanedOtsId = clean(otsId);
  const cleanedUserId = clean(userId);
  const cleanedBranch = clean(branch);
  const cleanedStatus = clean(status);

  if (user_role === 2) {
    if (!cleanedUserId || !mongoose.Types.ObjectId.isValid(cleanedUserId)) {
      return next(new AppError('User ID is required and must be valid for regular users.', 400));
    }
    if (cleanedBranch) {
      return next(new AppError('Branch filtering is not allowed for regular users.', 403));
    }
  } else if (user_role === 1) {
    if (!cleanedBranch) {
      return next(new AppError('Branch field is required for sub-admins to filter OTS forms.', 400));
    }
  } else if (user_role !== 0) {
    return next(new AppError('Access denied: your role is not authorized to perform this operation.', 403));
  }

  const filter = {};
  if (cleanedOtsId) filter.loan_number = sanitizeInput(cleanedOtsId);
  if (cleanedUserId) {
    if (!mongoose.Types.ObjectId.isValid(cleanedUserId)) {
      return next(new AppError('Invalid userId format.', 400));
    }
    filter.userId = new mongoose.Types.ObjectId(cleanedUserId);
  }
  if (cleanedBranch) filter.branch = sanitizeInput(cleanedBranch);
  if (cleanedStatus !== undefined) filter.status = cleanedStatus;

  const pipeline = [
    { $match: filter },
    {
      $lookup: {
        from: 'ackforms',
        localField: '_id',
        foreignField: 'ots_form_id',
        as: 'ackForm',
      },
    },
    {
      $lookup: {
        from: 'memorandums',
        localField: '_id',
        foreignField: 'otsFormId',
        as: 'memoForm',
      },
    },
    {
      $lookup: {
        from: 'certificateorders',
        localField: '_id',
        foreignField: 'otsId',
        as: 'certificateForm',
      },
    },
    {
      $addFields: {
        ackFile: { $arrayElemAt: ['$ackForm.img_link_sign_stamp', 0] },
        memoFile: { $arrayElemAt: ['$memoForm.pdfData', 0] },
        certificateFile: { $arrayElemAt: ['$certificateForm.certificate', 0] },
      },
    },
    {
      $project: {
        ackForm: 0,
        memoForm: 0,
        certificateForm: 0,
      },
    },
    {
      $facet: {
        paginatedData: [{ $sort: { createdAt: -1 } }, { $skip: skip }, { $limit: limit }],
        totalCount: [{ $count: 'count' }],
      },
    },
  ];

  const result = await OTSForm.aggregate(pipeline);
  const paginatedRaw = result[0].paginatedData || [];
  const totalItems = result[0].totalCount[0]?.count || 0;
  const totalPages = Math.ceil(totalItems / limit);

  const paginatedData = paginatedRaw.map((otsDoc) => ({ ots: otsDoc }));

  res.status(200).json({
    paginatedData,
    page,
    limit,
    totalItems,
    totalPages,
    previousPage: page > 1 ? page - 1 : null,
    nextPage: page < totalPages ? page + 1 : null,
    currentPageCount: paginatedData.length,
  });
});





// Count status for OTS applications
exports.getOTSStatusCounts = catchAsync(async (req, res) => {
  const { branch } = req.body;

  const pipeline = [];
  if (branch) pipeline.push({ $match: { branch } });
  pipeline.push({ $group: { _id: '$status', count: { $sum: 1 } } });

  const counts = await OTSForm.aggregate(pipeline);

  const statusCounts = { pending: 0, approved: 0, rejected: 0 };
  counts.forEach(({ _id, count }) => {
    if (_id === 0) statusCounts.pending = count;
    if (_id === 1) statusCounts.approved = count;
    if (_id === 2) statusCounts.rejected = count;
  });

  res.status(200).json({
    message: branch
      ? `OTS application status counts for branch '${branch}' retrieved successfully`
      : 'All OTS application status counts retrieved successfully',
    data: statusCounts
  });
});

// Get stats for a user (dashboard)
exports.getUserStats = catchAsync(async (req, res, next) => {
  const { userId } = req.body;
  if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
    return next(new AppError('Invalid or missing userId', 400));
  }

  const objectId = new mongoose.Types.ObjectId(userId);

  const counts = await OTSForm.aggregate([
    { $match: { userId: objectId } },
    { $group: { _id: '$status', count: { $sum: 1 } } }
  ]);

  const summary = { pending: 0, approved: 0, rejected: 0, total: 0 };
  counts.forEach(({ _id, count }) => {
    if (_id === 0) summary.pending = count;
    if (_id === 1) summary.approved = count;
    if (_id === 2) summary.rejected = count;
    summary.total += count;
  });

  const certificateCount = await CertificateOrder.countDocuments({ userId: objectId });

  res.status(200).json({
    message: 'User stats retrieved successfully',
    data: {
      ...summary,
      certificatesIssued: certificateCount
    }
  });
});






 