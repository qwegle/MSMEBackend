import { Types } from 'mongoose';
import validator from 'validator';
import ACKForm from '../../models/OSFC/acknowledgement.js';
import OTSForm from '../../models/OSFC/otsform.js';
import CertificateOrder from '../../models/OSFC/certificate.js'; // assumed import
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc.js';
import timezone from 'dayjs/plugin/timezone.js';
import AppError from '../../utils/AppError.js';
import catchAsync from '../../utils/catchAsync.js';
const { escape } = validator;
const sanitizeInput = input =>
  typeof input === 'string' ? escape(input.trim()) : input;
dayjs.extend(utc);
dayjs.extend(timezone);
// Create Acknowledgement Form
export const createAckForm = catchAsync(async (req, res, next) => {
  const filePath = req.file ? `${process.env.NODE_APP_URL}/uploads/${req.file.filename}` : null;
  if (!filePath) return next(new AppError('File is required', 400));

  const {
    loan_number, deposit_amount, deposit_date, deposit_type,
    ofsc_no, rac_date, name_of_recieving_officer, date_of_signature
  } = req.body;

  const sanitizedLoanNumber = sanitizeInput(loan_number);
  if (!sanitizedLoanNumber) return next(new AppError('Loan number is required', 400));

  const otsForm = await OTSForm.findOne({ loan_number: sanitizedLoanNumber });
  if (!otsForm) return next(new AppError('OTS Form not found for the given loan number', 404));

  const existingAck = await ACKForm.findOne({ ots_form_id: otsForm._id });
  if (existingAck) {
    return next(new AppError('Acknowledgement already exists for this loan number', 400));
  }

  const ackForm = new ACKForm({
    ots_form_id: otsForm._id,
    deposit_amount,
    deposit_date,
    deposit_type: sanitizeInput(deposit_type),
    ofsc_no: sanitizeInput(ofsc_no),
    rac_date,
    img_link_sign_stamp: filePath,
    name_of_recieving_officer: sanitizeInput(name_of_recieving_officer),
    date_of_signature,
  });

  await ackForm.save();

  await OTSForm.findByIdAndUpdate(
    otsForm._id,
    { status_msg: 'Acknowledgement generated by branch office' }
  );

  res.status(201).json({ message: 'Acknowledgement form saved successfully', ackForm });
});

// Reupload Signature or Stamp
export const reuploadAckSignature = catchAsync(async (req, res, next) => {
  const filePath = req.file ? `${process.env.NODE_APP_URL}/uploads/${req.file.filename}` : null;
  if (!filePath) return next(new AppError('Image is required for re-upload', 400));

  const loan_number = sanitizeInput(req.body.loan_number);
  if (!loan_number) return next(new AppError('Loan number is required', 400));

  const otsForm = await OTSForm.findOne({ loan_number });
  if (!otsForm) return next(new AppError('OTS Form not found for this loan number', 404));

  const ackForm = await ACKForm.findOne({ ots_form_id: otsForm._id });
  if (!ackForm) return next(new AppError('Acknowledgement not found for this loan number', 404));

  ackForm.img_link_sign_stamp = filePath;
  await ackForm.save();

  res.status(200).json({ message: 'Signature/stamp re-uploaded successfully', ackForm });
});

// Get All Acknowledgements
export const getAllAckForms = catchAsync(async (req, res) => {
  const forms = await ACKForm.find().populate('ots_form_id').sort({ createdAt: -1 });
  res.status(200).json(forms);
});

// Get Acknowledgements by User ID
export const getAckFormsByUserId = catchAsync(async (req, res, next) => {
  const userId = sanitizeInput(req.params.userId);
  if (!userId) return next(new AppError('User ID is required', 400));

  const forms = await ACKForm.find({ userId }).populate('ots_form_id').sort({ createdAt: -1 });

  if (!forms.length) return next(new AppError('No acknowledgements found for this user.', 404));

  res.status(200).json(forms);
});

// Filter Acknowledgements with Role-Based Rules
export const filterAckForms = catchAsync(async (req, res, next) => {
  const { user_role, id: requesterId } = req.user;
  const { userId, loan_number, branch } = req.body;
  const page = parseInt(req.body.page) || 1;
  const limit = parseInt(req.body.limit) || 10;
  const skip = (page - 1) * limit;

  // Role-based filtering rules
  if (user_role === 2) {
    if (!userId || !Types.ObjectId.isValid(userId)) {
      return next(new AppError('User ID is required and must be valid for regular users.', 400));
    }
    if (branch) {
      return next(new AppError('Regular users cannot filter by branch.', 403));
    }
  } else if (user_role === 1) {
    if (!branch) {
      return next(new AppError('Branch field is required for sub-admins.', 400));
    }
  } else if (user_role !== 0) {
    return next(new AppError('Access denied for this role.', 403));
  }

  const matchConditions = {};

  if (userId) {
    if (!Types.ObjectId.isValid(userId)) {
      return next(new AppError('Invalid userId format.', 400));
    }
    matchConditions['otsDetails.userId'] = new Types.ObjectId(userId);
  }

  if (loan_number) {
    matchConditions['otsDetails.loan_number'] = sanitizeInput(loan_number);
  }

  if (branch) {
    matchConditions['otsDetails.branch'] = sanitizeInput(branch);
  }

  const pipeline = [
    {
      $lookup: {
        from: 'otsforms',
        localField: 'ots_form_id',
        foreignField: '_id',
        as: 'otsDetails',
      },
    },
    { $unwind: '$otsDetails' },
    ...(Object.keys(matchConditions).length > 0 ? [{ $match: matchConditions }] : []),
    {
      $project: {
        _id: 0,
        first_name: '$otsDetails.first_name',
        last_name: '$otsDetails.last_name',
        loan_number: '$otsDetails.loan_number',
        img_link_sign_stamp: 1,
        createdAt: 1,
      },
    },
    {
      $facet: {
        paginatedData: [{ $sort: { createdAt: -1 } }, { $skip: skip }, { $limit: limit }],
        totalCount: [{ $count: 'count' }],
      },
    },
  ];

  const result = await ACKForm.aggregate(pipeline);
  const paginatedRaw = result[0].paginatedData;
  const totalCount = result[0].totalCount[0]?.count || 0;
  const totalPages = Math.ceil(totalCount / limit);

  // Convert UTC createdAt to Asia/Kolkata and format as dd/mm/yyyy
  const paginatedData = paginatedRaw.map((item) => {
    const formattedCreatedAt = dayjs(item.createdAt)
      .tz('Asia/Kolkata')
      .format('DD/MM/YYYY');
    return {
      ...item,
      createdAt: formattedCreatedAt,
    };
  });

  res.status(200).json({
    paginatedData,
    page,
    limit,
    totalItems: totalCount,
    totalPages,
    previousPage: page > 1 ? page - 1 : null,
    nextPage: page < totalPages ? page + 1 : null,
    currentPageCount: paginatedData.length,
  });
});

