import { Types } from 'mongoose';
import validator from 'validator';
import ACKForm from '../../models/OSFC/acknowledgement.js';
import OTSForm from '../../models/OSFC/otsform.js';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc.js';
import timezone from 'dayjs/plugin/timezone.js';
import AppError from '../../utils/AppError.js';
import catchAsync from '../../utils/catchAsync.js';
import { decryptRequestBody, sendEncryptedResponse } from '../../utils/encryption.js';
const { escape } = validator;
const sanitizeInput = input =>
  typeof input === 'string' ? escape(input.trim()) : input;
dayjs.extend(utc);
dayjs.extend(timezone);

export const createAckForm = 
  catchAsync(async (req, res, next) => {
    const fileUrl = req.file?.url;
    if (!fileUrl) return next(new AppError('File is required', 400));
    const {
      loan_number,
      deposit_amount,
      deposit_date,
      deposit_type,
      ofsc_no,
      rac_date,
      name_of_recieving_officer,
      date_of_signature,
    } = req.decryptedBody;
    const sanitizedLoanNumber = sanitizeInput(loan_number);
    if (!sanitizedLoanNumber)
      return next(new AppError('Loan number is required', 400));
    const otsForm = await OTSForm.findOne({ loan_number: sanitizedLoanNumber });
    if (!otsForm)
      return next(new AppError('OTS Form not found for the given loan number', 404));
    const existingAck = await ACKForm.findOne({ ots_form_id: otsForm._id });
    if (existingAck) {
      return next(new AppError('Acknowledgement already exists for this loan number', 400));
    }
    const ackForm = await ACKForm.create({
      ots_form_id: otsForm._id,
      deposit_amount,
      deposit_date,
      deposit_type: sanitizeInput(deposit_type),
      ofsc_no: sanitizeInput(ofsc_no),
      rac_date,
      img_link_sign_stamp: fileUrl,
      name_of_recieving_officer: sanitizeInput(name_of_recieving_officer),
      date_of_signature,
    });
    await OTSForm.findByIdAndUpdate(
      otsForm._id,
      { status_msg: 'Acknowledgement generated by branch office' }
    );
    sendEncryptedResponse(res, 201, {
      message: 'Acknowledgement form saved successfully',
      ackForm,
    });
  })
export const reuploadAckSignature = catchAsync(async (req, res, next) => {
    const fileUrl = req.file?.url;
    if (!fileUrl) return next(new AppError('Image is required for re-upload', 400));
    const loan_number = sanitizeInput(req.decryptedBody.loan_number);
    if (!loan_number) return next(new AppError('Loan number is required', 400));
    const otsForm = await OTSForm.findOne({ loan_number });
    if (!otsForm) return next(new AppError('OTS Form not found for this loan number', 404));
    const ackForm = await ACKForm.findOne({ ots_form_id: otsForm._id });
    if (!ackForm) return next(new AppError('Acknowledgement not found for this loan number', 404));
    ackForm.img_link_sign_stamp = fileUrl;
    await ackForm.save();
    sendEncryptedResponse(res, 200, {
      message: 'Signature/stamp re-uploaded successfully',
      ackForm,
    });
  })
export const getAllAckForms = catchAsync(async (req, res) => {
  const forms = await ACKForm.find().populate('ots_form_id').sort({ createdAt: -1 });
  sendEncryptedResponse(res, 200, forms);
});
export const getAckFormsByUserId = catchAsync(async (req, res, next) => {
  const userId = sanitizeInput(req.params.userId);
  if (!userId) return next(new AppError('User ID is required', 400));

  const forms = await ACKForm.find({ userId }).populate('ots_form_id').sort({ createdAt: -1 });
  if (!forms.length) return next(new AppError('No acknowledgements found for this user.', 404));

  sendEncryptedResponse(res, 200, forms);
});
export const filterAckForms = [
  decryptRequestBody,
  catchAsync(async (req, res, next) => {
    const { user_role, id: requesterId } = req.user;
    const { userId, loan_number, branch, page = 1, limit = 10 } = req.decryptedBody;
    const skip = (page - 1) * limit;

    if (user_role === 2) {
      if (!userId || !Types.ObjectId.isValid(userId)) {
        return next(new AppError('User ID is required and must be valid for regular users.', 400));
      }
      if (branch) {
        return next(new AppError('Regular users cannot filter by branch.', 403));
      }
    } else if (user_role === 1) {
      if (!branch) {
        return next(new AppError('Branch field is required for sub-admins.', 400));
      }
    } else if (user_role !== 0) {
      return next(new AppError('Access denied for this role.', 403));
    }

    const matchConditions = {};
    if (userId) {
      if (!Types.ObjectId.isValid(userId)) {
        return next(new AppError('Invalid userId format.', 400));
      }
      matchConditions['otsDetails.userId'] = new Types.ObjectId(userId);
    }
    if (loan_number) {
      matchConditions['otsDetails.loan_number'] = sanitizeInput(loan_number);
    }
    if (branch) {
      matchConditions['otsDetails.branch'] = sanitizeInput(branch);
    }
    const pipeline = [
      {
        $lookup: {
          from: 'otsforms',
          localField: 'ots_form_id',
          foreignField: '_id',
          as: 'otsDetails',
        },
      },
      { $unwind: '$otsDetails' },
      ...(Object.keys(matchConditions).length > 0 ? [{ $match: matchConditions }] : []),
      {
        $project: {
          _id: 0,
          first_name: '$otsDetails.first_name',
          last_name: '$otsDetails.last_name',
          loan_number: '$otsDetails.loan_number',
          img_link_sign_stamp: 1,
          createdAt: 1,
        },
      },
      {
        $facet: {
          paginatedData: [{ $sort: { createdAt: -1 } }, { $skip: skip }, { $limit: limit }],
          totalCount: [{ $count: 'count' }],
        },
      },
    ];
    const result = await ACKForm.aggregate(pipeline);
    const paginatedRaw = result[0].paginatedData;
    const totalCount = result[0].totalCount[0]?.count || 0;
    const totalPages = Math.ceil(totalCount / limit);
    const paginatedData = paginatedRaw.map((item) => {
      const formattedCreatedAt = dayjs(item.createdAt)
        .tz('Asia/Kolkata')
        .format('DD/MM/YYYY');
      return {
        ...item,
        createdAt: formattedCreatedAt,
      };
    });
    sendEncryptedResponse(res, 200, {
      paginatedData,
      page,
      limit,
      totalItems: totalCount,
      totalPages,
      previousPage: page > 1 ? page - 1 : null,
      nextPage: page < totalPages ? page + 1 : null,
      currentPageCount: paginatedData.length,
    });
  }),
];
