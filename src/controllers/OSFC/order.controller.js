import SettlementOrder from '../../models/OSFC/settlementOrder.js';
import OTSForm from '../../models/OSFC/otsform.js';
import AckForm from '../../models/OSFC/acknowledgement.js';
import Memorandum from '../../models/OSFC/memorandum.js';
import AppError from '../../utils/AppError.js';
import catchAsync from '../../utils/catchAsync.js';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc.js';
import timezone from 'dayjs/plugin/timezone.js';

import { decryptRequestBody, sendEncryptedResponse } from '../../utils/encryption.js';

dayjs.extend(utc);
dayjs.extend(timezone);

export const uploadSettlementOrder = catchAsync(async (req, res, next) => {
    const fileUrl = req.file?.url;
    if (!fileUrl) return next(new AppError('PDF file is required.', 400));

    const { loan_number } = req.decryptedBody;
    if (!loan_number) return next(new AppError('loan_number is required.', 400));

    const otsForm = await OTSForm.findOne({ loan_number });
    if (!otsForm) return next(new AppError('OTSForm not found for provided loan_number.', 404));

    const ackForm = await AckForm.findOne({ ots_form_id: otsForm._id });
    if (!ackForm) return next(new AppError('AckForm not found for this OTSForm.', 404));

    const memo = await Memorandum.findOne({ ackId: ackForm._id });
    if (!memo) return next(new AppError('Memorandum not found for this AckForm.', 404));

    if (memo.status !== 1) {
      return next(new AppError('Memorandum must be approved before uploading settlement order.', 400));
    }

    const existingOrder = await SettlementOrder.findOne({ otsId: otsForm._id });
    if (existingOrder) {
      return next(new AppError('Settlement Order already exists for this Loan Number.', 400));
    }

    const newOrder = new SettlementOrder({
      userId: otsForm.userId,
      otsId: otsForm._id,
      AckId: ackForm._id,
      memoId: memo._id,
      pdfData: fileUrl,
    });

    const savedOrder = await newOrder.save();

    await OTSForm.findByIdAndUpdate(
      otsForm._id,
      { status_msg: 'Settlement Order generated by admin office' },
      { new: true }
    );

    sendEncryptedResponse(res, 201, {
      message: 'Settlement order created and application status updated successfully.',
      id: savedOrder._id,
    });
  })

export const reuploadSettlementOrder = catchAsync(async (req, res, next) => {
    const fileUrl = req.file?.url;
    if (!fileUrl) return next(new AppError('PDF file is required.', 400));

    const { loan_number } = req.decryptedBody;
    if (!loan_number) return next(new AppError('loan_number is required.', 400));

    const otsForm = await OTSForm.findOne({ loan_number });
    if (!otsForm) return next(new AppError('OTSForm not found for provided loan_number.', 404));

    const existingOrder = await SettlementOrder.findOne({ otsId: otsForm._id });
    if (!existingOrder) return next(new AppError('No existing Settlement Order found to update.', 404));

    existingOrder.pdfData = fileUrl;
    await existingOrder.save();

    sendEncryptedResponse(res, 200, {
      message: 'Settlement Order PDF reuploaded successfully.',
      id: existingOrder._id,
    });
  })

export const getSettlementOrdersByUserId = catchAsync(async (req, res, next) => {
  const { userId } = req.params;
  if (!userId) return next(new AppError('User ID is required', 400));
  const orders = await SettlementOrder.find({ userId })
    .populate('otsId')
    .populate('AckId')
    .populate('memoId')
    .sort({ createdAt: -1 });
  if (!orders.length) return next(new AppError('No settlement orders found for this user.', 404));
  sendEncryptedResponse(res, 200, orders);
});

export const listSettlementOrders = catchAsync(async (req, res) => {
  const orders = await SettlementOrder.find()
    .populate('userId')
    .populate('otsId')
    .populate('AckId')
    .populate('memoId')
    .sort({ createdAt: -1 });

  sendEncryptedResponse(res, 200, orders);
});

export const filterSettlementOrders = [
  decryptRequestBody,
  catchAsync(async (req, res, next) => {
    const { userId, loan_number } = req.decryptedBody;
    const page = parseInt(req.decryptedBody.page) || 1;
    const limit = parseInt(req.decryptedBody.limit) || 10;
    const filter = {};

    if (userId && loan_number) {
      const ots = await OTSForm.findOne({ userId, loan_number });
      if (!ots) return next(new AppError('No matching OTSForm found.', 404));
      filter.userId = userId;
      filter.otsId = ots._id;
    } else if (userId) {
      filter.userId = userId;
    } else if (loan_number) {
      const ots = await OTSForm.findOne({ loan_number });
      if (!ots) return next(new AppError('No OTSForm found for loan_number.', 404));
      filter.otsId = ots._id;
    }
    const totalItems = await SettlementOrder.countDocuments(filter);
    const totalPages = Math.ceil(totalItems / limit);
    const startIndex = (page - 1) * limit;
    const orders = await SettlementOrder.find(filter)
      .populate('userId')
      .populate('otsId')
      .populate('AckId')
      .populate('memoId')
      .sort({ createdAt: -1 })
      .skip(startIndex)
      .limit(limit);
    if (!orders.length) return next(new AppError('No settlement orders found for the filters.', 404));
    const paginatedData = orders.map(order => {
      const createdAt = dayjs(order.createdAt)
        .tz('Asia/Kolkata')
        .format('DD/MM/YYYY');
      const orderObj = order.toObject();
      if (orderObj.otsId?.createdAt) {
        orderObj.otsId.createdAt = dayjs(orderObj.otsId.createdAt)
          .tz('Asia/Kolkata')
          .format('DD/MM/YYYY');
      }
      return {
        ...orderObj,
        createdAt,
      };
    });
    sendEncryptedResponse(res, 200, {
      paginatedData,
      page,
      limit,
      totalItems,
      totalPages,
      previousPage: page > 1 ? page - 1 : null,
      nextPage: page < totalPages ? page + 1 : null,
      currentPageCount: paginatedData.length,
    });
  }),
];
