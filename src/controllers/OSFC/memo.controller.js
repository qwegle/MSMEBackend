import Memorandum from '../../models/OSFC/memorandum.js';
import OTSForm from '../../models/OSFC/otsform.js';
import AckForm from '../../models/OSFC/acknowledgement.js';
import validator from 'validator';
import mongoose from 'mongoose';
import catchAsync from '../../utils/catchAsync.js';
import AppError from '../../utils/AppError.js';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc.js';
import timezone from 'dayjs/plugin/timezone.js';
import { decryptRequestBody, sendEncryptedResponse } from '../../utils/encryption.js';

dayjs.extend(utc);
dayjs.extend(timezone);

const { escape } = validator;
const sanitizeInput = input =>
  typeof input === 'string' ? escape(input.trim()) : input;

// Upload Memorandum
export const uploadPdf = catchAsync(async (req, res, next) => {
    const fileUrl = req.file?.url;
    if (!fileUrl) return next(new AppError('PDF file is required', 400));

    const { loan_number } = req.decryptedBody;
    if (!loan_number) return next(new AppError('loan_number is required', 400));

    const otsForm = await OTSForm.findOne({ loan_number });
    if (!otsForm) return next(new AppError('OTSForm not found for given loan_number', 404));

    const ackForm = await AckForm.findOne({ ots_form_id: otsForm._id });
    if (!ackForm) return next(new AppError('Acknowledgement form not found for this OTSForm', 404));

    const existingMemo = await Memorandum.findOne({ otsFormId: otsForm._id });
    if (existingMemo)
      return next(new AppError('Memorandum already exists for this loan number', 400));

    const newMemo = await Memorandum.create({
      userId: otsForm.userId,
      otsFormId: otsForm._id,
      ackId: ackForm._id,
      pdfData: fileUrl,
    });

    await OTSForm.findByIdAndUpdate(otsForm._id, {
      status_msg: 'Memorandum generated by branch office',
    });

    res.status(201).json({
      message: 'PDF uploaded and memorandum saved successfully',
      id: newMemo._id,
    });
  })

// Reupload Memorandum
export const reuploadMemo = catchAsync(async (req, res, next) => {
    const fileUrl = req.file?.url;
    if (!fileUrl) return next(new AppError('PDF file is required', 400));

    const { loan_number } = req.decryptedBody;
    if (!loan_number) return next(new AppError('loan_number is required', 400));

    const otsForm = await OTSForm.findOne({ loan_number });
    if (!otsForm) return next(new AppError('OTSForm not found for given loan_number', 404));

    const ackForm = await AckForm.findOne({ ots_form_id: otsForm._id });
    if (!ackForm) return next(new AppError('Acknowledgement form not found for this OTSForm', 404));

    const existingMemo = await Memorandum.findOne({ otsFormId: otsForm._id });

    if (existingMemo) {
      existingMemo.pdfData = fileUrl;
      await existingMemo.save();

      await OTSForm.findByIdAndUpdate(otsForm._id, {
        status_msg: 'Memorandum reuploaded by branch office',
      });

      res.status(201).json({
        message: 'PDF reuploaded and memorandum updated successfully',
        id: existingMemo._id,
      });
    }

    const newMemo = await Memorandum.create({
      userId: otsForm.userId,
      otsFormId: otsForm._id,
      ackId: ackForm._id,
      pdfData: fileUrl,
    });

    await OTSForm.findByIdAndUpdate(otsForm._id, {
      status_msg: 'Memorandum uploaded by branch office',
    });

    sendEncryptedResponse(res, 201, {
      message: 'PDF uploaded and new memorandum created',
      id: newMemo._id,
    });
  })


// Update Memorandum Status
export const updateMemoStatus = [
  decryptRequestBody,
  catchAsync(async (req, res, next) => {
    const { memoId, status, remarks } = req.decryptedBody;

    if (!memoId || status === undefined) {
      return next(new AppError('memoId and status are required', 400));
    }

    const validStatuses = [0, 1, 2];
    if (!validStatuses.includes(status)) {
      return next(new AppError('Invalid status value', 400));
    }

    const updatedMemo = await Memorandum.findByIdAndUpdate(
      memoId,
      { status, remarks },
      { new: true }
    );

    if (!updatedMemo) return next(new AppError('Memorandum not found', 404));

    const statusMap = {
      0: 'Application is being processed by admin office',
      1: 'Application has been approved.',
      2: 'Application is rejected by head office',
    };

    await OTSForm.findByIdAndUpdate(updatedMemo.otsFormId, {
      status_msg: statusMap[status],
    });

    sendEncryptedResponse(res, 200, {
      message: 'Memo status updated successfully',
      memo: updatedMemo,
    });
  }),
];

// Get memos by userId
export const getMemosByUserId = [
  decryptRequestBody,
  catchAsync(async (req, res, next) => {
    const { userId } = req.decryptedBody;
    if (!userId) return next(new AppError('User ID is required', 400));

    const memos = await Memorandum.find({ userId }).sort({ createdAt: -1 });

    if (!memos.length) {
      return next(new AppError('No memorandums found for this user', 404));
    }

    sendEncryptedResponse(res, 200, memos);
  }),
];

// Get all memos with filters and pagination
export const getAllMemos = [
  decryptRequestBody,
  catchAsync(async (req, res, next) => {
    const { loan_number, userId, branch, status, page = 1, limit = 10 } = req.decryptedBody;
    const { user_role } = req.user;

    let memoFilter = {};
    let otsFilter = {};

    // Role-based validation
    if (user_role === 2) {
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        return next(new AppError('User ID is required and must be valid for regular users.', 400));
      }
      if (branch) {
        return next(new AppError('Regular users are not allowed to filter by branch.', 403));
      }
    } else if (user_role === 1) {
      if (!branch) {
        return next(new AppError('Branch is required for sub-admins.', 400));
      }
    } else if (user_role !== 0) {
      return next(new AppError('Access denied: your role is not authorized to perform this operation.', 403));
    }

    if (loan_number) {
      const otsForm = await OTSForm.findOne({ loan_number });
      if (!otsForm) return next(new AppError('No OTS Form found for the given loan number', 404));
      memoFilter.otsFormId = otsForm._id;
    } else {
      if (userId && !mongoose.Types.ObjectId.isValid(userId)) {
        return next(new AppError('Invalid userId format.', 400));
      }

      if (userId) otsFilter.userId = userId;
      if (branch) otsFilter.branch = sanitizeInput(branch);
      if (status) memoFilter.status = status;

      const matchedOtsForms = await OTSForm.find(otsFilter).select('_id');
      if (!matchedOtsForms.length) {
        return sendEncryptedResponse(res, 200, {
          paginatedData: [],
          page,
          limit,
          totalItems: 0,
          totalPages: 0,
          previousPage: null,
          nextPage: null,
          currentPageCount: 0,
        });
      }

      memoFilter.otsFormId = { $in: matchedOtsForms.map(ots => ots._id) };
    }

    const totalItems = await Memorandum.countDocuments(memoFilter);
    const totalPages = Math.ceil(totalItems / limit);
    const startIndex = (page - 1) * limit;

    const memos = await Memorandum.find(memoFilter)
      .sort({ createdAt: -1 })
      .skip(startIndex)
      .limit(limit)
      .populate('userId', 'username email user_type user_role branch aadharNumber')
      .populate('otsFormId')
      .populate('ackId');

    const paginatedData = memos.map(memo => ({
      ...memo.toObject(),
      createdAtFormatted: dayjs(memo.createdAt)
        .tz('Asia/Kolkata')
        .format('DD/MM/YYYY'),
    }));

    sendEncryptedResponse(res, 200, {
      paginatedData,
      page,
      limit,
      totalItems,
      totalPages,
      previousPage: page > 1 ? page - 1 : null,
      nextPage: page < totalPages ? page + 1 : null,
      currentPageCount: paginatedData.length,
    });
  }),
];
