import Memorandum from '../../models/OSFC/memorandum.js';
import OTSForm from '../../models/OSFC/otsform.js';
import AckForm from '../../models/OSFC/acknowledgement.js';
import validator from 'validator';
import mongoose from 'mongoose';
import catchAsync from '../../utils/catchAsync.js';
import AppError from '../../utils/AppError.js';
const { escape } = validator;
const sanitizeInput = input =>
  typeof input === 'string' ? escape(input.trim()) : input;

export const uploadPdf = catchAsync(async (req, res, next) => {
  const filePath = req.file ? `${process.env.NODE_APP_URL}/uploads/${req.file.filename}` : null;
  if (!filePath) return next(new AppError('PDF file is required', 400));

  const { loan_number } = req.body;
  if (!loan_number) return next(new AppError('loan_number is required', 400));

  const otsForm = await OTSForm.findOne({ loan_number });
  if (!otsForm) return next(new AppError('OTSForm not found for given loan_number', 404));

  const ackForm = await AckForm.findOne({ ots_form_id: otsForm._id });
  if (!ackForm) return next(new AppError('Acknowledgement form not found for this OTSForm', 404));

  const existingMemo = await Memorandum.findOne({ otsFormId: otsForm._id });
  if (existingMemo) return next(new AppError('Memorandum already exists for this loan number', 400));

  const newMemo = await Memorandum.create({
    userId: otsForm.userId,
    otsFormId: otsForm._id,
    ackId: ackForm._id,
    pdfData: filePath,
  });

  await OTSForm.findByIdAndUpdate(otsForm._id, {
    status_msg: 'Memorandum generated by branch office',
  });

  res.status(201).json({
    message: 'PDF uploaded and memorandum saved successfully',
    id: newMemo._id,
  });
});

export const updateMemoStatus = catchAsync(async (req, res, next) => {
  const { memoId, status, remarks } = req.body;

  if (!memoId || status === undefined) {
    return next(new AppError('memoId and status are required', 400));
  }

  const validStatuses = [0, 1, 2];
  if (!validStatuses.includes(status)) {
    return next(new AppError('Invalid status value', 400));
  }

  const updatedMemo = await Memorandum.findByIdAndUpdate(
    memoId,
    { status, remarks },
    { new: true }
  );

  if (!updatedMemo) return next(new AppError('Memorandum not found', 404));

  const statusMap = {
    0: 'Application is being processed by admin office',
    1: 'Application has been approved.',
    2: 'Application is rejected by head office',
  };

  await OTSForm.findByIdAndUpdate(updatedMemo.otsFormId, {
    status_msg: statusMap[status],
  });

  res.json({ message: 'Memo status updated successfully', memo: updatedMemo });
});

export const reuploadMemo = catchAsync(async (req, res, next) => {
  const filePath = req.file ? `${process.env.NODE_APP_URL}/uploads/${req.file.filename}` : null;
  if (!filePath) return next(new AppError('PDF file is required', 400));

  const { loan_number } = req.body;
  if (!loan_number) return next(new AppError('loan_number is required', 400));

  const otsForm = await OTSForm.findOne({ loan_number });
  if (!otsForm) return next(new AppError('OTSForm not found for given loan_number', 404));

  const ackForm = await AckForm.findOne({ ots_form_id: otsForm._id });
  if (!ackForm) return next(new AppError('Acknowledgement form not found for this OTSForm', 404));

  const existingMemo = await Memorandum.findOne({ otsFormId: otsForm._id });

  if (existingMemo) {
    existingMemo.pdfData = filePath;
    await existingMemo.save();

    await OTSForm.findByIdAndUpdate(
      otsForm._id,
      { status_msg: 'Memorandum reuploaded by branch office' }
    );

    return res.status(200).json({
      message: 'PDF reuploaded and memorandum updated successfully',
      id: existingMemo._id,
    });
  }

  const newMemo = await Memorandum.create({
    userId: otsForm.userId,
    otsFormId: otsForm._id,
    ackId: ackForm._id,
    pdfData: filePath,
  });

  await OTSForm.findByIdAndUpdate(
    otsForm._id,
    { status_msg: 'Memorandum uploaded by branch office' }
  );

  res.status(201).json({
    message: 'PDF uploaded and new memorandum created',
    id: newMemo._id,
  });
});

export const getMemosByUserId = catchAsync(async (req, res, next) => {
  const { userId } = req.params;
  if (!userId) return next(new AppError('User ID is required', 400));

  const memos = await Memorandum.find({ userId }).sort({ createdAt: -1 });

  if (!memos.length) {
    return next(new AppError('No memorandums found for this user', 404));
  }

  res.json(memos);
});

export const getAllMemos = catchAsync(async (req, res, next) => {
  const { loan_number, userId, branch, status } = req.body;
  const { user_role } = req.user;
  const page = parseInt(req.body.page) || 1;
  const limit = parseInt(req.body.limit) || 10;

  let memoFilter = {};
  let otsFilter = {};

  // ðŸ›¡ï¸ Role-based filtering logic
  if (user_role === 2) { // User
    if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
      return next(new AppError('User ID is required and must be valid for regular users.', 400));
    }
    if (branch) {
      return next(new AppError('Regular users are not allowed to filter by branch.', 403));
    }
  } else if (user_role === 1) { // Sub-admin
    if (!branch) {
      return next(new AppError('Branch is required for sub-admins.', 400));
    }
  } else if (user_role !== 0) { // Invalid role
    return next(new AppError('Access denied: your role is not authorized to perform this operation.', 403));
  }

  if (loan_number) {
    const otsForm = await OTSForm.findOne({ loan_number });
    if (!otsForm) return next(new AppError('No OTS Form found for the given loan number', 404));
    memoFilter.otsFormId = otsForm._id;
  } else {
    if (userId) {
      if (!mongoose.Types.ObjectId.isValid(userId)) {
        return next(new AppError('Invalid userId format.', 400));
      }
      otsFilter.userId = userId;
    }
    if (branch) otsFilter.branch = sanitizeInput(branch);
    if (status) memoFilter.status = status;

    const matchedOtsForms = await OTSForm.find(otsFilter).select('_id');
    if (!matchedOtsForms.length) {
      return res.json({
        paginatedData: [],
        page,
        limit,
        totalItems: 0,
        totalPages: 0,
        previousPage: null,
        nextPage: null,
        currentPageCount: 0,
      });
    }

    memoFilter.otsFormId = { $in: matchedOtsForms.map(ots => ots._id) };
  }

  const totalItems = await Memorandum.countDocuments(memoFilter);
  const totalPages = Math.ceil(totalItems / limit);
  const startIndex = (page - 1) * limit;

  const memos = await Memorandum.find(memoFilter)
    .sort({ createdAt: -1 })
    .skip(startIndex)
    .limit(limit)
    .populate('userId', 'username email user_type user_role branch aadharNumber')
    .populate('otsFormId')
    .populate('ackId');

  res.json({
    paginatedData: memos,
    page,
    limit,
    totalItems,
    totalPages,
    previousPage: page > 1 ? page - 1 : null,
    nextPage: page < totalPages ? page + 1 : null,
    currentPageCount: memos.length,
  });
});
